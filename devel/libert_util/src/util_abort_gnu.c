/*
  This file implements the fully fledged util abort() function which
  assumes that the current build has the following features:

    fork()      : To support calling external program addr2line().
    pthread     : To serialize the use of util abort() - not very important.
    execinfo.h  : The backtrace functions backtrace() and backtrace symbols().
    _GNU_SOURCE : To get the dladdr() function.

  If not all these features are availbale the simpler version in
  util abort_simple.c is built instead.
*/



/**
  This function uses the external program addr2line to convert the
  hexadecimal adress given by the libc function backtrace() into a
  function name and file:line.

  Observe that the function is quite involved, so if util_abort() is
  called because something is seriously broken, it might very well fail.

  The executable should be found from one line in the backtrace with
  the function util_bt_alloc_current_executable(), the argument
  bt_symbol is the lines generated by the  bt_symbols() function.

  This function is purely a helper function for util_abort().
*/

#define __USE_GNU  1 // Must be defined to get access to the dladdr() function; Man page says the symbol should be: _GNU_SOURCE but that does not seem to work?
#define _GNU_SOURCE
#include <dlfcn.h>

#define UNDEFINED_FUNCTION "??"

static bool util_addr2line_lookup__(const char * executable , const void * bt_addr , const char * bt_symbol , char ** func_name , char ** file_line , int * line_nr, bool subtract_base_adress) {
  char *tmp_file = util_alloc_tmp_file("/tmp" , "addr2line" , true);
  {
    Dl_info dl_info;
    char ** argv;

    dladdr(bt_addr , &dl_info);

    printf("dli_fname:%s   dli_fbase:%p   dli_sname:%s   dli_saddr:%p \n",dl_info.dli_fname , dl_info.dli_fbase , dl_info.dli_sname , dl_info.dli_saddr);
    
    argv    = util_calloc(3 , sizeof * argv );
    argv[0] = util_alloc_string_copy("--functions");
    argv[1] = util_alloc_sprintf("--exe=%s" , dl_info.dli_fname);
    {
      char * rel_address = (char *) bt_addr;
      if (subtract_base_adress)
        rel_address -= (char *) dl_info.dli_fbase;
      argv[2] = util_alloc_sprintf("%p" , (void *) rel_address);
    }
    printf("bt_addr    %p \n",bt_addr);
    printf("fname      %s \n",dl_info.dli_fname);
    printf("base:      %p \n",dl_info.dli_fbase);
    printf("rel        %s \n",argv[2]);
    printf("backtrace: %p \n",bt_addr);
    printf("%s  %s  %s\n",argv[0] , argv[1] , argv[2]);
    util_fork_exec("addr2line" , 3  , (const char **) argv , true , NULL , NULL , NULL , tmp_file , NULL);
    util_free_stringlist(argv , 3);
  }
  
  {
    bool at_eof;
    FILE * stream = util_fopen(tmp_file , "r");
    *func_name = util_fscanf_alloc_line(stream , &at_eof);
    if (strcmp(*func_name , UNDEFINED_FUNCTION) == 0) {
      char * tmp_file_line = util_fscanf_alloc_line(stream , &at_eof);
      char * line_string;
      util_binary_split_string( tmp_file_line , ":" , false , file_line , &line_string);
      
    }
    
    printf("func: %s  file_line:%s  \n",*func_name , *file_line);
    printf("-----------------------------------------------------------------\n");
    fclose(stream);
  }
  util_unlink_existing(tmp_file);
  free(tmp_file);
  if (strcmp(*func_name , UNDEFINED_FUNCTION) == 0)
    return false;
  else
    return true;
}


bool util_addr2line_lookup(const char * executable , const void * bt_addr , const char * bt_symbol , char ** func_name , char ** file_line , int * line_nr) {
  if (util_addr2line_lookup__(NULL , bt_addr , bt_symbol , func_name , file_line , line_nr , false))
    return true;
  else
    return util_addr2line_lookup__(NULL , bt_addr , bt_symbol , func_name , file_line , line_nr , true);
}


/**
  This function prints a message to stderr and aborts. The function is
  implemented with the help of a variable length argument list - just
  like printf(fmt , arg1, arg2 , arg3 ...);

  Observe that it is __VERY__ important that the arguments and the
  format string match up, otherwise the util_abort() routine will hang
  indefinetely; without printing anything to stderr.

  A backtrace is also included, with the help of the exernal utility
  addr2line, this backtrace is converted into usable
  function/file/line information (provided the required debugging
  information is compiled in).
*/

static pthread_mutex_t __abort_mutex  = PTHREAD_MUTEX_INITIALIZER; /* Used purely to serialize the util_abort() routine. */

/**
   If the variable __current_executable has been set, that value is
   returned as the executable, otherwise an attempt (which generally
   works) is made to try to extract it from the output from
   bt_symbols().
   
   This function takes one string from the string list generated by
   bt_symbols(). From this string it extracts the full path to the
   current executable. This path is needed for subsequent calls to
   util_addr2line_lookup().
   
   This function is purely a helper function for util_abort().
*/

static char * util_bt_alloc_current_executable(const char * bt_symbol) {
  if (__current_executable != NULL) 
    return util_alloc_string_copy(__current_executable );
  else {
    if (bt_symbol != NULL) {
      int paren_pos = 0;
      char * path;
      while (bt_symbol[paren_pos] != '(' && bt_symbol[paren_pos] != ' ')
        paren_pos++;
      
      path = util_alloc_substring_copy(bt_symbol , 0 , paren_pos);
      if (util_is_abs_path(path))
        return path;
      else {
        char * full_path = util_alloc_PATH_executable( path );
        free(path);
        return full_path;
      }
    } else 
      return NULL;
  }
}


void util_abort(const char * fmt , ...) {
  pthread_mutex_lock( &__abort_mutex ); /* Abort before unlock() */
  {
    va_list ap;

    va_start(ap , fmt);
    printf("\n\n");
    fprintf(stderr,"\n\n");
    vfprintf(stderr , fmt , ap);
    va_end(ap);

    /*
      The backtrace is based on calling the external program
      addr2line; the call is based on util_fork_exec() which is
      currently only available on POSIX.
    */

    const bool include_backtrace = true;
    if (include_backtrace) {
      const int max_bt = 50;
      void *bt_addr[max_bt];
      char *executable;
      char **strings;
      char ** func_list;
      char ** file_line_list;
      int    max_func_length = 0;
      int    size,i;
  
      if (__abort_program_message != NULL) {
        fprintf(stderr,"--------------------------------------------------------------------------------\n");
        fprintf(stderr,"%s",__abort_program_message);
        fprintf(stderr,"--------------------------------------------------------------------------------\n");
      }

      fprintf(stderr,"\n");
      fprintf(stderr,"****************************************************************************\n");
      fprintf(stderr,"**                                                                        **\n");
      fprintf(stderr,"**           A fatal error occured, and we have to abort.                 **\n");
      fprintf(stderr,"**                                                                        **\n");
      fprintf(stderr,"**  We now *try* to provide a backtrace, which would be very useful       **\n");
      fprintf(stderr,"**  when debugging. The process of making a (human readable) backtrace    **\n");
      fprintf(stderr,"**  is quite complex, among other things it involves several calls to the **\n");
      fprintf(stderr,"**  external program addr2line. We have arrived here because the program  **\n");
      fprintf(stderr,"**  state is already quite broken, so the backtrace might be (seriously)  **\n");
      fprintf(stderr,"**  broken as well.                                                       **\n");
      fprintf(stderr,"**                                                                        **\n");
      fprintf(stderr,"****************************************************************************\n");
      size       = backtrace(bt_addr , max_bt);
      strings    = backtrace_symbols(bt_addr , size);    
      executable = util_bt_alloc_current_executable(strings[0]);
      if (executable != NULL) {
        fprintf(stderr,"Current executable : %s \n",executable);
        
        func_list      = util_calloc(size , sizeof * func_list      );
        file_line_list = util_calloc(size , sizeof * file_line_list );
        
        for (i=0; i < size; i++) {
          int line_nr;
          util_addr2line_lookup(executable , bt_addr[i] , strings[i] , &func_list[i] , &file_line_list[i] , &line_nr);
          max_func_length = util_int_max(max_func_length , strlen(func_list[i]));
        }
        
        {
          char string_fmt[64];
          sprintf(string_fmt, " #%s02d %s-%ds(..) in %ss   \n" , "%" , "%" , max_func_length , "%");
          fprintf(stderr , "--------------------------------------------------------------------------------\n");
          for (i=0; i < size; i++) {
            
            int line_nr;
            if (util_sscanf_int(file_line_list[i] , &line_nr))
              fprintf(stderr, string_fmt , i , func_list[i], file_line_list[i]);
            else
              fprintf(stderr, string_fmt , i , func_list[i], file_line_list[i]);
          }
          fprintf(stderr , "--------------------------------------------------------------------------------\n");
          util_free_stringlist(func_list      , size);
          util_free_stringlist(file_line_list , size);
        }
      } else
        fprintf(stderr,"Could not determine executable file for:%s - no backtrace. \n",strings[0]);
      
      free(strings);
      util_safe_free(executable);
    }

    signal(SIGABRT , SIG_DFL);
    fprintf(stderr , "Aborting ... \n");
    abort();
    // Would have preferred abort() here - but that comes in conflict with the SIGABRT signal.
  }
  pthread_mutex_unlock( &__abort_mutex );
}

